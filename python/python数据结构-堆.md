# 数据结构-堆

堆是一种优先队列。优先队列让你能够以任意顺序添加对象，并随时（可能是在两次添加对象之间）找出（并删除）最小的元素。相比于列表方法min，这样做的效率要高得多。

元素的排列顺序并不像看起来那么随意。它们虽然不是严格排序的，但必须保证一点：位置i处的元素总是大于位置i // 2处的元素（反过来说就是小于位置2 * i和2 * i + 1处的元素）。这是底层堆算法的基础，称为堆特征（heap property）

实际上，Python没有独立的堆类型，而只有一个包含一些堆操作函数的模块。这个模块名为`heapq`（其中的q表示队列），它包含6个函数，其中前4个与堆操作直接相关。必须使用`列表`来表示堆对象本身。
```
import heapq
```


## heappush(heap, x)     

将x压入堆中
```
>>> import heapq
>>> heap = []
>>> heapq.heappush(heap, 1)
>>> heap
[1]
>>>
```

## heapq.heapify(list)
将list转换为堆， 堆的索引0永远是最小值
```
>>> heap = [4,3,2,1]
>>> heapq.heapify(heap)
>>> heap
[1, 3, 2, 4]
>>>
```

## heapq.heappop(heap)
删除并返回最小值
```
>>> heap = [1, 2, 3, 4]
>>> heapq.heappop(heap)
1
>>> heap
[2, 4, 3]
>>>
```

## heapq.heapreplace(heap, item)
删除并返回最小值， 然后添加新元素
```
>>> heap = [1, 2, 3, 4]
>>> heapq.heapreplace(heap, 5)
1
>>> heap
[2, 4, 3, 5]
>>>
```

## heapq.nlargest(n, heap)
以数组返回heap中n个`最大`的数
```
>>> heap = [1, 2, 3, 4, 5, 6, 7, 8]
>>> heapq.nlargest(2, heap)
[8, 7]
>>> heap
[1, 2, 3, 4, 5, 6, 7, 8]
>>>
```

## heapq.nsmallest(n, heap)
以数组返回heap中n个`最小`的数
```
>>> heap = [1, 2, 3, 4, 5, 6, 7, 8]
>>> heapq.nsmallest(2, heap)
[1, 2]
>>> heap
[1, 2, 3, 4, 5, 6, 7, 8]
>>>
```


# 堆排序

## 简介
堆排序(Heap Sort)是利用堆这种数据结构所设计的一种排序算法。

堆的结构是一棵完全二叉树的结构，并且满足堆积的性质：每个节点(叶节点除外)的值都大于等于(或都小于等于)它的子节点。

堆排序先按从上到下、从左到右的顺序将待排序列表中的元素构造成一棵完全二叉树，然后对完全二叉树进行调整，使其满足堆积的性质：每个节点(叶节点除外)的值都大于等于(或都小于等于)它的子节点。构建出堆后，将堆顶与堆尾进行交换，然后将堆尾从堆中取出来，取出来的数据就是最大(或最小)的数据。重复构建堆并将堆顶和堆尾进行交换，取出堆尾的数据，直到堆中的数据全部被取出，列表排序完成。

堆结构分为大顶堆和小顶堆：

- 大顶堆：每个节点(叶节点除外)的值都大于等于其子节点的值，根节点的值是所有节点中最大的，所以叫大顶堆，在堆排序算法中用于升序排列。

- 小顶堆：每个节点(叶节点除外)的值都小于等于其子节点的值，根节点的值是所有节点中最小的，所以叫小顶堆，在堆排序算法中用于降序排列。


## 原理

堆排序的原理如下：

1. 将待排序列表中的数据按从上到下、从左到右的顺序构造成一棵完全二叉树。

2. 将完全二叉树中每个节点(叶节点除外)的值与其子节点(子节点有一个或两个)中较大的值进行比较，如果节点的值小于子节点的值，则交换他们的位置(大顶堆，小顶堆反之)。

3. 将节点与子节点进行交换后，要继续比较子节点与孙节点的值，直到不需要交换或子节点是叶节点时停止。比较完所有的非叶节点后，即可构建出堆结构。

4. 将数据构造成堆结构后，将堆顶与堆尾交换，然后将堆尾从堆中取出来，添加到已排序序列中，完成一轮堆排序，堆中的数据个数减1。

5. 重复步骤2,3,4，直到堆中的数据全部被取出，列表排序完成。


## python实现堆排序
```
# coding=utf-8
def heap_sort(array):
    first = len(array) // 2 - 1
    for start in range(first, -1, -1):
        # 从下到上，从右到左对每个非叶节点进行调整，循环构建成大顶堆
        big_heap(array, start, len(array) - 1)
    for end in range(len(array) - 1, 0, -1):
        # 交换堆顶和堆尾的数据
        array[0], array[end] = array[end], array[0]
        # 重新调整完全二叉树，构造成大顶堆
        big_heap(array, 0, end - 1)
    return array
 
 
def big_heap(array, start, end):
    root = start
    # 左孩子的索引
    child = root * 2 + 1
    while child <= end:
        # 节点有右子节点，并且右子节点的值大于左子节点，则将child变为右子节点的索引
        if child + 1 <= end and array[child] < array[child + 1]:
            child += 1
        if array[root] < array[child]:
            # 交换节点与子节点中较大者的值
            array[root], array[child] = array[child], array[root]
            # 交换值后，如果存在孙节点，则将root设置为子节点，继续与孙节点进行比较
            root = child
            child = root * 2 + 1
        else:
            break
 
 
if __name__ == '__main__':
    array = [10, 17, 50, 7, 30, 24, 27, 45, 15, 5, 36, 21]
    print(heap_sort(array))
```
